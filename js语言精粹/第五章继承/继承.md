# 第五章 继承
继承提供了两个有用的服务： 

* 代码重用
* 引入了一套类型系统的规范

Javascript 是一门弱类型的语言，从不需要类型转换。对象继承关系变得无关紧要。对于一个对象来说重要的是它能做什么，而不是它从哪里来。   
Javascript 是一门基于原型的语言，这意味着对象直接从其他对象继承。  
Javascript 提供了丰富的代码重用模式，用于模拟那些基于类的模式，同时它也可以支持其他更具表现力的模式。

## 伪类
Javascript 的原型存在着许多矛盾。它不直接让对象从其他对象继承，反而插入了一个多余的见阶层: 通过构造器函数产生对象。   
在基于类的语言中，类继承是代码重用的唯一方式，而 Javascript 有这更多且更好的选择

## 对象说明符
有时候，构造器要接收一大串参数。要记住参数的顺序非常困奶。在这种情况下，如果我们在编写构造器时让它接受一个简单的对象说明符，可能会更加友好。

## 原型
在一个纯粹的原型模式中，我们会摒弃类，转而专注于对象。基于原型的继承相比基于类的继承的概念上更为简单: 一个新对象可以继承一个旧对象的属性。  
差异化继承： 通过定制一个新的对象，我们指出它与所基于的基本对象的区别。

## 函数化
继承模式的一个缺点就是没法保护隐私。 可以使用应用块模式：  
1、创建一个新对象  
2、有选择地定义私有实例变量和方法  
3、给这个新对象扩充方法  
4、返回那个新对象

函数化模式有很大的灵活性。它相比伪类模式不仅带来的工作更少，还让我们得到更好的封装和信息隐藏，以及访问父类方法的能力。    
如果对象的所有状态都是私有的，那么该对象就成为一个 "**防伪**" 对象。该对象的属性可以被替换或删除，但该对象的完整性不会受到损害。如果我们用函数化的样式创建一个对象，并且该对象的所有方法都不使用 this 或 that，那么该对象就是**持久性**的。**一个持久性对象**就是一个简单功能函数的集合。    
一个持久性的对象不会被入侵。访问一个持久性的对象时，除非方法授权，否则攻击者不能访问对象的内部状态 

## 部件
我们可以从一套部件中把对象组装出来。  
一个构造函数可以从一套部件中把对象组装出来。 Javascript 的弱类型在此处是一个巨大的优势，因为我们无须花费精力去了解对象在类型系统中的继承关系。相反我们只需关注于它们的个性特征。

部件这节，确实没能理解。


